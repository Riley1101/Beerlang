#!/usr/bin/env bun
// @bun
var FO=function(){const O=new Map;for(let[Q,$]of Object.entries(D)){for(let[U,H]of Object.entries($))D[U]={open:`\x1B[${H[0]}m`,close:`\x1B[${H[1]}m`},$[U]=D[U],O.set(H[0],H[1]);Object.defineProperty(D,Q,{value:$,enumerable:!1})}return Object.defineProperty(D,"codes",{value:O,enumerable:!1}),D.color.close="\x1B[39m",D.bgColor.close="\x1B[49m",D.color.ansi=KO(),D.color.ansi256=XO(),D.color.ansi16m=ZO(),D.bgColor.ansi=KO(10),D.bgColor.ansi256=XO(10),D.bgColor.ansi16m=ZO(10),Object.defineProperties(D,{rgbToAnsi256:{value(Q,$,U){if(Q===$&&$===U){if(Q<8)return 16;if(Q>248)return 231;return Math.round((Q-8)/247*24)+232}return 16+36*Math.round(Q/255*5)+6*Math.round($/255*5)+Math.round(U/255*5)},enumerable:!1},hexToRgb:{value(Q){const $=/[a-f\d]{6}|[a-f\d]{3}/i.exec(Q.toString(16));if(!$)return[0,0,0];let[U]=$;if(U.length===3)U=[...U].map((J)=>J+J).join("");const H=Number.parseInt(U,16);return[H>>16&255,H>>8&255,H&255]},enumerable:!1},hexToAnsi256:{value:(Q)=>D.rgbToAnsi256(...D.hexToRgb(Q)),enumerable:!1},ansi256ToAnsi:{value(Q){if(Q<8)return 30+Q;if(Q<16)return 90+(Q-8);let $,U,H;if(Q>=232)$=((Q-232)*10+8)/255,U=$,H=$;else{Q-=16;const JO=Q%36;$=Math.floor(Q/36)/5,U=Math.floor(JO/6)/5,H=JO%6/5}const J=Math.max($,U,H)*2;if(J===0)return 30;let K=30+(Math.round(H)<<2|Math.round(U)<<1|Math.round($));if(J===2)K+=60;return K},enumerable:!1},rgbToAnsi:{value:(Q,$,U)=>D.ansi256ToAnsi(D.rgbToAnsi256(Q,$,U)),enumerable:!1},hexToAnsi:{value:(Q)=>D.ansi256ToAnsi(D.hexToAnsi256(Q)),enumerable:!1}}),D};var KO=(O=0)=>(Q)=>`\x1B[${Q+O}m`,XO=(O=0)=>(Q)=>`\x1B[${38+O};5;${Q}m`,ZO=(O=0)=>(Q,$,U)=>`\x1B[${38+O};2;${Q};${$};${U}m`,D={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgGray:[100,49],bgGrey:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}},gO=Object.keys(D.modifier),jO=Object.keys(D.color),EO=Object.keys(D.bgColor),cO=[...jO,...EO],BO=FO(),X=BO;var C=(()=>{if(navigator.userAgentData){const O=navigator.userAgentData.brands.find(({brand:Q})=>Q==="Chromium");if(O&&O.version>93)return 3}if(/\b(Chrome|Chromium)\//.test(navigator.userAgent))return 1;return 0})(),PO=C!==0&&{level:C,hasBasic:!0,has256:C>=2,has16m:C>=3},_O={stdout:PO,stderr:PO},LO=_O;function VO(O,Q,$){let U=O.indexOf(Q);if(U===-1)return O;const H=Q.length;let J=0,K="";do K+=O.slice(J,U)+Q+$,J=U+H,U=O.indexOf(Q,J);while(U!==-1);return K+=O.slice(J),K}function wO(O,Q,$,U){let H=0,J="";do{const K=O[U-1]==="\r";J+=O.slice(H,K?U-1:U)+Q+(K?"\r\n":"\n")+$,H=U+1,U=O.indexOf("\n",H)}while(U!==-1);return J+=O.slice(H),J}var _=function(O){return CO(O)};var{stdout:MO,stderr:NO}=LO,c=Symbol("GENERATOR"),z=Symbol("STYLER"),B=Symbol("IS_EMPTY"),YO=["ansi","ansi","ansi256","ansi16m"],A=Object.create(null),fO=(O,Q={})=>{if(Q.level&&!(Number.isInteger(Q.level)&&Q.level>=0&&Q.level<=3))throw new Error("The `level` option should be an integer from 0 to 3");const $=MO?MO.level:0;O.level=Q.level===void 0?$:Q.level};var CO=(O)=>{const Q=(...$)=>$.join(" ");return fO(Q,O),Object.setPrototypeOf(Q,_.prototype),Q};Object.setPrototypeOf(_.prototype,Function.prototype);for(let[O,Q]of Object.entries(X))A[O]={get(){const $=R(this,k(Q.open,Q.close,this[z]),this[B]);return Object.defineProperty(this,O,{value:$}),$}};A.visible={get(){const O=R(this,this[z],!0);return Object.defineProperty(this,"visible",{value:O}),O}};var x=(O,Q,$,...U)=>{if(O==="rgb"){if(Q==="ansi16m")return X[$].ansi16m(...U);if(Q==="ansi256")return X[$].ansi256(X.rgbToAnsi256(...U));return X[$].ansi(X.rgbToAnsi(...U))}if(O==="hex")return x("rgb",Q,$,...X.hexToRgb(...U));return X[$][O](...U)},RO=["rgb","hex","ansi256"];for(let O of RO){A[O]={get(){const{level:$}=this;return function(...U){const H=k(x(O,YO[$],"color",...U),X.color.close,this[z]);return R(this,H,this[B])}}};const Q="bg"+O[0].toUpperCase()+O.slice(1);A[Q]={get(){const{level:$}=this;return function(...U){const H=k(x(O,YO[$],"bgColor",...U),X.bgColor.close,this[z]);return R(this,H,this[B])}}}}var hO=Object.defineProperties(()=>{},{...A,level:{enumerable:!0,get(){return this[c].level},set(O){this[c].level=O}}}),k=(O,Q,$)=>{let U,H;if($===void 0)U=O,H=Q;else U=$.openAll+O,H=Q+$.closeAll;return{open:O,close:Q,openAll:U,closeAll:H,parent:$}},R=(O,Q,$)=>{const U=(...H)=>bO(U,H.length===1?""+H[0]:H.join(" "));return Object.setPrototypeOf(U,hO),U[c]=O,U[z]=Q,U[B]=$,U},bO=(O,Q)=>{if(O.level<=0||!Q)return O[B]?"":Q;let $=O[z];if($===void 0)return Q;const{openAll:U,closeAll:H}=$;if(Q.includes("\x1B"))while($!==void 0)Q=VO(Q,$.close,$.open),$=$.parent;const J=Q.indexOf("\n");if(J!==-1)Q=wO(Q,H,U,J);return U+Q+H};Object.defineProperties(_.prototype,A);var vO=_(),lO=_({level:NO?NO.level:0});var L=vO;function IO(O){const $=Bun.argv[2];if($===void 0)console.log("Usage: beer [script]"),process.exit(64);const U=Bun.file($);if(!/(\.beer)$/g.test(U.name))console.log("File must have .beer extension"),process.exit(64);U.text().then((K)=>{O(K)})}var S=L;class y{_log;constructor(){this._log=S}info(O){if(typeof O==="object")O=JSON.stringify(O,null,2);console.log(this._log.blue(O))}error(O){if(typeof O==="object")O=JSON.stringify(O,null,2);console.log(this._log.red(O))}warn(O){if(typeof O==="object")O=JSON.stringify(O,null,2);console.log(this._log.yellow(O))}debug(O){if(typeof O==="object")O=JSON.stringify(O,null,2);console.log(this._log.green(O))}}class i extends Error{constructor(O){super(O);this.name="ClientError"}}class P extends Error{token;constructor(O,Q){super(Q);this.token=O,this.name="RuntimeError"}}class Z extends Error{token;constructor(O,Q){super(Q);this.token=O,this.name="SyntaxError"}}class zO{hasCliError=!1;hasRuntimeError=!1;hasSyntaxError=!1;log(O){if(O instanceof i)console.log(S.red(O.message));else if(O instanceof P)console.log(S.red(O.message));else console.log(S.red(O.message))}report(O){if(O instanceof i)this.hasCliError=!0;else if(O instanceof P)this.hasRuntimeError=!0;else this.hasSyntaxError=!0;throw this.log(O),O}}var q=new zO;class f{O;constructor(O){this.statements=O;this.statements=O}accept(O){return O.visitBlockStmt(this)}}class h{O;constructor(O){this.expression=O;this.expression=O}accept(O){return O.visitExpressionStmt(this)}}class m{O;constructor(O){this.expression=O;this.expression=O}accept(O){return O.visitPrintStmt(this)}}class a{O;Q;$;constructor(O,Q,$){this.condition=O;this.thenBranch=Q;this.elseBranch=$;this.condition=O,this.thenBranch=Q,this.elseBranch=$}accept(O){return O.visitIfStmt(this)}}class b{O;Q;constructor(O,Q){this.condition=O;this.body=Q;this.condition=O,this.body=Q}accept(O){return O.visitWhileStmt(this)}}class l{O;Q;constructor(O,Q){this.keyword=O;this.value=Q;this.keyword=O,this.value=Q}accept(O){return O.visitReturnStmt(this)}}class T{O;Q;$;constructor(O,Q,$){this.name=O;this.params=Q;this.body=$;this.name=O,this.params=Q,this.body=$}accept(O){return O.visitFunctionStmt(this)}}class p{O;Q;constructor(O,Q){this.keyword=O;this.method=Q;this.keyword=O,this.method=Q}accept(O){return O.visitSuperExpr(this)}}class o{O;Q;$;constructor(O,Q,$){this.name=O;this.superclass=Q;this.methods=$;this.name=O,this.superclass=Q,this.methods=$}accept(O){return O.visitClassStmt(this)}}class s{O;Q;constructor(O,Q){this.name=O;this.initializer=Q;this.name=O,this.initializer=Q}accept(O){return O.visitVarStmt(this)}}class n{O;Q;$;constructor(O,Q,$){this.object=O;this.name=Q;this.value=$;this.object=O,this.name=Q,this.value=$}accept(O){return O.visitSetExpr(this)}}class r{O;constructor(O){this.keyword=O;this.keyword=O}accept(O){return O.visitThisExpr(this)}}class v{O;Q;constructor(O,Q){this.object=O;this.name=Q;this.object=O,this.name=Q}accept(O){return O.visitGetExpr(this)}}class j{left;operator;right;constructor(O,Q,$){this.left=O,this.operator=Q,this.right=$}accept(O){return O.visitBinaryExpr(this)}}class t{operator;right;constructor(O,Q){this.operator=O,this.right=Q}accept(O){return O.visitUnaryExpr(this)}}class N{value;constructor(O){this.value=O}accept(O){return O.visitLiteralExpr(this)}}class e{expression;constructor(O){this.expression=O}accept(O){return O.visitGroupingExpr(this)}}class E{O;constructor(O){this.name=O;this.name=O}accept(O){return O.visitVariableExpr(this)}}class OO{O;Q;constructor(O,Q){this.name=O;this.value=Q;this.name=O,this.value=Q}accept(O){return O.visitAssignExpr(this)}}class QO{O;Q;$;constructor(O,Q,$){this.callee=O;this.paren=Q;this.args=$;this.callee=O,this.paren=Q,this.args=$}accept(O){return O.visitCallExpr(this)}}class u{O;Q;$;constructor(O,Q,$){this.left=O;this.operator=Q;this.right=$;this.left=O,this.operator=Q,this.right=$}accept(O){return O.visitLogicalExpr(this)}}class $O{visitSetExpr(O){return this.parenthesize(`set ${O.name.lexeme}`,O.value)}visitGetExpr(O){return this.parenthesize(`get ${O.name.lexeme}`,O.object)}visitAssignExpr(O){return this.parenthesize(O.name.lexeme,O.value)}visitBinaryExpr(O){return this.parenthesize(O.operator.lexeme,O.left,O.right)}visitUnaryExpr(O){return this.parenthesize(O.operator.lexeme,O.right)}visitLiteralExpr(O){if(O.value===null)return"nil";return O.value.toString()}visitLogicalExpr(O){return this.parenthesize(O.operator.lexeme,O.left,O.right)}visitExpressionStmt(O){return this.parenthesize("expression",O.expression)}visitPrintStmt(O){return this.parenthesize("print",O.expression)}visitVarStmt(O){const Q=new E(O.name);if(O.initializer)return this.parenthesize("var",Q,O.initializer);return this.parenthesize("var",Q)}visitBlockStmt(O){let Q="(block ";for(let $ of O.statements)Q+="\n"+this.indent($.accept(this));return Q+=")",Q}visitForStmt(O){let Q=`(for ${this.stringify(O.initializer)} ${this.stringify(O.condition)} ${this.stringify(O.increment)}\n`;const $=this.stringify(O.body);return Q+=this.indent($),Q+=")",Q}visitWhileStmt(O){let Q=`(while ${this.stringify(O.condition)}\n`;const $=this.stringify(O.body);return Q+=this.indent($),Q+=")",Q}visitReturnStmt(O){if(O.value)return this.parenthesize("return",O.value);return this.parenthesize("return")}visitFunctionStmt(O){let Q=`(fun ${O.name.lexeme} (`;for(let U of O.params)Q+=U.lexeme+" ";Q+=")\n";const $=this.stringify(O.body);return Q+=this.indent($),Q+=")",Q}visitClassStmt(O){let Q=`(class ${O.name.lexeme}`;return O.methods.forEach(($)=>{Q+="\n"+this.indent(this.stringify($))}),Q+=")",Q}visitIfStmt(O){let Q=`(if ${this.stringify(O.condition)}\n`;const $=this.stringify(O.thenBranch);if(Q+=this.indent($),O.elseBranch!==null){Q+="\n";const U=this.stringify(O.elseBranch);Q+=this.indent(U)}return Q+=")",Q}visitVariableExpr(O){return O.name.lexeme}visitGroupingExpr(O){return this.parenthesize("group",O.expression)}visitThisExpr(O){return O.keyword.lexeme}visitCallExpr(O){return this.parenthesize("call",O.callee,...O.args)}visitSuperExpr(O){return O.keyword.lexeme}parenthesize(O,...Q){let $=`(${O}`;for(let U of Q)$+=` ${U.accept(this)}`;return $+=")",$}indent(O){return O.split("\n").map((Q)=>`  ${Q}`).join("\n")}print(O){return O.accept(this)}stringify(O){if(O===null)return"nil";if(O instanceof Array)return O.map((Q)=>Q.accept(this)).join("\n");else return O.accept(this)}print_ast(O){console.log(S.cyan(this.stringify(O)))}generate_ast(O){return this.stringify(O).split("\n")}}class V{enclosing;values=new Map;constructor(O){if(this.enclosing=null,O)this.enclosing=O}define(O,Q){this.values.set(O,Q)}get(O){if(this.values.has(O))return this.values.get(O);if(this.enclosing!==null)return this.enclosing.get(O);return q.report(new ReferenceError(`Undefined variable '${O}'`))}assign(O,Q){if(this.values.has(O)){this.values.set(O,Q);return}if(this.enclosing!==null){this.enclosing.assign(O,Q);return}return q.report(new ReferenceError(`Undefined variable '${O}'`))}ancestor(O){let Q=this;for(let $=0;$<O;$++)Q=Q.enclosing;return Q}get_at(O,Q){return this.ancestor(O).values.get(Q)}assign_at(O,Q,$){this.ancestor(O).values.set(Q,$)}}var G;(function(W){W["LEFT_PAREN"]="LEFT_PAREN";W["RIGHT_PAREN"]="RIGHT_PAREN";W["LEFT_BRACE"]="LEFT_BRACE";W["RIGHT_BRACE"]="RIGHT_BRACE";W["LEFT_BRACKET"]="LEFT_BRACKET";W["RIGHT_BRACKET"]="RIGHT_BRACKET";W["COMMA"]="COMMA";W["DOT"]="DOT";W["MINUS"]="MINUS";W["PLUS"]="PLUS";W["MODULO"]="MODULO";W["SEMICOLON"]="SEMICOLON";W["SLASH"]="SLASH";W["STAR"]="STAR";W["BANG"]="BANG";W["BANG_EQUAL"]="BANG_EQUAL";W["EQUAL"]="EQUAL";W["EQUAL_EQUAL"]="EQUAL_EQUAL";W["GREATER"]="GREATER";W["GREATER_EQUAL"]="GREATER_EQUAL";W["LESS"]="LESS";W["LESS_EQUAL"]="LESS_EQUAL";W["IDENTIFIER"]="IDENTIFIER";W["STRING"]="STRING";W["NUMBER"]="NUMBER";W["AND"]="AND";W["CLASS"]="CLASS";W["ELSE"]="ELSE";W["FALSE"]="FALSE";W["FUN"]="FUN";W["FOR"]="FOR";W["IF"]="IF";W["NIL"]="NIL";W["OR"]="OR";W["PRINT"]="PRINT";W["RETURN"]="RETURN";W["SUPER"]="SUPER";W["THIS"]="THIS";W["TRUE"]="TRUE";W["VAR"]="VAR";W["WHILE"]="WHILE";W["EOF"]="EOF"})(G||(G={}));var AO={and:G.AND,class:G.CLASS,else:G.ELSE,false:G.FALSE,for:G.FOR,fun:G.FUN,if:G.IF,nil:G.NIL,or:G.OR,print:G.PRINT,return:G.RETURN,super:G.SUPER,this:G.THIS,true:G.TRUE,var:G.VAR,while:G.WHILE};class I{}class Y extends I{O;Q;$;static Return=class O{value;constructor(Q){this.value=Q}};constructor(O,Q,$=!1){super();this.declaration=O;this.closure=Q;this.is_initializer=$;this.declaration=O,this.closure=Q,this.is_initializer=$}to_string(){return`<fun ${this.declaration.name.lexeme}>`}arity(){return this.declaration.params.length}bind(O){let Q=new V(this.closure);return Q.define("this",O),new Y(this.declaration,Q,this.is_initializer)}call(O,Q){const $=new V(this.closure);for(let U=0;U<this.declaration.params.length;U++)$.define(this.declaration.params[U].lexeme,Q[U]);try{O.execute_block(this.declaration.body,$)}catch(U){if(U instanceof Y.Return){if(this.is_initializer)return this.closure.get_at(0,"this");return U.value}throw U}if(this.is_initializer)return this.closure.get_at(0,"this");return null}}class GO extends I{constructor(){super(...arguments)}arity(){return 0}call(){return Date.now().valueOf()/1000}to_string(){return"<native fn>"}}class d extends I{Q;$;name;constructor(O,Q,$){super();this.methods=Q;this.superclass=$;this.name=O,this.methods=Q,this.superclass=$}find_method(O){if(this.methods.has(O))return this.methods.get(O);if(this.superclass!==null)return this.superclass.find_method(O);return null}arity(){const O=this.find_method("init");if(O===null)return 0;return O.arity()}call(O,Q){let $=new F(this);const U=this.find_method("init");if(U!==null)U.bind($).call(O,Q);return $}to_string(){return`<class ${this.name}>`}}class F{O;fields=new Map;constructor(O){this.klass=O;this.klass=O}get(O){if(this.fields.has(O.lexeme))return this.fields.get(O.lexeme);let Q=this.klass.find_method(O.lexeme);if(Q)return Q.bind(this);return q.report(new SyntaxError(`Undefined property '${O.lexeme}'.`))}set(O,Q){this.fields.set(O.lexeme,Q)}to_string(){return`<instance ${this.klass.name}>`}}class UO{globals=new V;environment=this.globals;locals=new Map;constructor(){this.globals.define("clock",new GO)}resolve(O,Q){this.locals.set(O,Q)}look_up_variable(O,Q){const $=this.locals.get(Q);if($!==void 0)return this.environment.get_at($,O.lexeme);else return this.globals.get(O.lexeme)}interpret(O){try{for(let Q of O)this.execute(Q)}catch(Q){throw Q}}execute(O){O.accept(this)}evaluate(O){return O.accept(this)}is_equal(O,Q){if(O===null&&Q===null)return!0;if(O===null)return!1;return O===Q}checkNumberOperands(O,Q,$){if(typeof Q==="number"&&typeof $==="number")return;else q.report(new SyntaxError("Operands must be numbers at "+O.line+O.lexeme))}is_truthy(O){if(O===null)return!1;if(typeof O==="boolean")return O;return!0}stringify(O){if(O===null)return"nil";if(typeof O==="number")return O.toString();if(O instanceof I)return O.to_string();if(O instanceof F)return O.to_string();return O.toString()}execute_block(O,Q){const $=this.environment;try{this.environment=Q;for(let U of O)U&&this.execute(U)}finally{this.environment=$}}visitThisExpr(O){return this.look_up_variable(O.keyword,O)}visitAssignExpr(O){let Q=this.evaluate(O.value),$=this.locals.get(O);if($!==void 0)this.environment.assign_at($,O.name.lexeme,Q);else this.globals.assign(O.name.lexeme,Q);return Q}visitBinaryExpr(O){let Q=this.evaluate(O.left),$=this.evaluate(O.right);switch(O.operator.type){case G.GREATER:return this.checkNumberOperands(O.operator,Q,$),Q>$;case G.GREATER_EQUAL:return this.checkNumberOperands(O.operator,Q,$),Q>=$;case G.LESS:return this.checkNumberOperands(O.operator,Q,$),Q<$;case G.LESS_EQUAL:return this.checkNumberOperands(O.operator,Q,$),Q<=$;case G.MINUS:return this.checkNumberOperands(O.operator,Q,$),Q-$;case G.BANG_EQUAL:return!this.is_equal(Q,$);case G.EQUAL_EQUAL:return this.is_equal(Q,$);case G.SLASH:if(this.checkNumberOperands(O.operator,Q,$),$===0)q.report(new Error("Division by zero at  line "+O.operator.line+O.operator.lexeme));return Q/$;case G.STAR:return this.checkNumberOperands(O.operator,Q,$),Q*$;case G.PLUS:if(typeof Q==="number"&&typeof $==="number")return Q+$;if(typeof Q==="string"&&typeof $==="string")return Q+$;q.report(new SyntaxError("Operands must be two numbers or two strings at "+O.operator.line+O.operator.lexeme))}return null}visitUnaryExpr(O){let Q=this.evaluate(O.right);switch(O.operator.type){case G.MINUS:return-Q;case G.BANG:return!this.is_truthy(Q)}return null}visitLiteralExpr(O){return O.value}visitGroupingExpr(O){return this.evaluate(O.expression)}visitVariableExpr(O){return this.look_up_variable(O.name,O)}visitLogicalExpr(O){let Q=this.evaluate(O.left);if(O.operator.type===G.OR){if(this.is_truthy(Q))return Q}else if(!this.is_truthy(Q))return Q;return this.evaluate(O.right)}visitCallExpr(O){let Q=this.evaluate(O.callee),$=[];for(let H of O.args)$.push(this.evaluate(H));if(!(Q instanceof I))throw q.report(new SyntaxError("Can only call functions and classes."));if($.length!==Q.arity())throw q.report(new SyntaxError(`Expected ${Q.arity()} arguments but got ${$.length}.`));return Q.call(this,$)}visitClassStmt(O){let Q=null;if(O.superclass!==null){if(Q=this.evaluate(O.superclass),!(Q instanceof d))throw q.report(new SyntaxError("Superclass must be a class."))}if(this.environment.define(O.name.lexeme,null),O.superclass!==null)this.environment=new V(this.environment),this.environment.define("super",Q);let $=new Map;for(let H of O.methods){let J=new Y(H,this.environment,H.name.lexeme==="init");$.set(H.name.lexeme,J)}let U=new d(O.name.lexeme,$,Q);if(Q!==null)this.environment=this.environment.enclosing;this.environment.assign(O.name.lexeme,U)}visitForStmt(O){if(O.initializer)this.execute(O.initializer);while(this.is_truthy(this.evaluate(O.condition))){if(this.execute(O.body),O.increment===null)return;this.evaluate(O.increment)}}visitWhileStmt(O){while(this.is_truthy(this.evaluate(O.condition)))this.execute(O.body)}visitReturnStmt(O){let Q=null;if(O.value!==null)Q=this.evaluate(O.value);throw new Y.Return(Q)}visitFunctionStmt(O){let Q=new Y(O,this.environment,!1);this.environment.define(O.name.lexeme,Q);return}visitPrintStmt(O){let Q=this.evaluate(O.expression);console.log(this.stringify(Q))}visitExpressionStmt(O){this.evaluate(O.expression)}visitVarStmt(O){let Q=null;if(O.initializer!==null)Q=this.evaluate(O.initializer);this.environment.define(O.name.lexeme,Q)}visitBlockStmt(O){this.execute_block(O.statements,new V(this.environment))}visitIfStmt(O){if(this.is_truthy(this.evaluate(O.condition)))this.execute(O.thenBranch);else if(O.elseBranch!==null)this.execute(O.elseBranch)}visitGetExpr(O){let Q=this.evaluate(O.object);if(Q instanceof F)return Q.get(O.name);throw q.report(new SyntaxError("Only instances have properties."))}visitSetExpr(O){let Q=this.evaluate(O.object);if(!(Q instanceof F))throw q.report(new SyntaxError("Only instances have fields."));let $=this.evaluate(O.value);return Q.set(O.name,$),$}visitSuperExpr(O){let Q=this.locals.get(O),$=this.environment.get_at(Q,"super"),U=this.environment.get_at(Q-1,"this"),H=$.find_method(O.method.lexeme);if(H===null)throw q.report(new SyntaxError(`Undefined property '${O.method.lexeme}'.`));return H.bind(U)}}class WO{tokens;current;constructor(O){this.tokens=O,this.current=0}reset_parser(){this.current=0,this.tokens=[]}set_tokens(O){this.tokens=O}parse(){const O=[];while(!this.is_at_end())try{O.push(this.declaration())}catch(Q){if(Q instanceof Z)throw q.report(Q);this.synchronize()}return O}class_declaration(){let O=this.consume(G.IDENTIFIER,"Expect class name."),Q=null;if(this.match(G.LESS))this.consume(G.IDENTIFIER,"Expect superclass name."),Q=new E(this.previous());this.consume(G.LEFT_BRACE,"Expect '{' before class body.");let $=[];while(!this.check(G.RIGHT_BRACE)&&!this.is_at_end())$.push(this.function_declaration("method"));return this.consume(G.RIGHT_BRACE,"Expect '}' after class body."),new o(O,Q,$)}function_declaration(O){let Q=this.consume(G.IDENTIFIER,`Expect ${O} name.`);this.consume(G.LEFT_PAREN,`Expect '(' after ${O} name.`);const $=[];if(!this.check(G.RIGHT_PAREN))do{if($.length>=255)q.report(new Z(this.peek(),"Cannot have more than 255 parameters."));$.push(this.consume(G.IDENTIFIER,"Expect parameter name."))}while(this.match(G.COMMA));this.consume(G.RIGHT_PAREN,"Expect ')' after parameters."),this.consume(G.LEFT_BRACE,`Expect '{' before ${O} body.`);const U=this.block();return new T(Q,$,U)}declaration(){if(this.match(G.CLASS))return this.class_declaration();if(this.match(G.FUN))return this.function_declaration("function");if(this.match(G.VAR))return this.var_declaration();return this.statement()}var_declaration(){const O=this.consume(G.IDENTIFIER,"Expect variable name.");let Q=null;if(this.match(G.EQUAL))Q=this.expression();return this.consume(G.SEMICOLON,"Expect ';' after variable declaration."),new s(O,Q)}block(){const O=[];while(!this.check(G.RIGHT_BRACE)&&!this.is_at_end())O.push(this.declaration());return this.consume(G.RIGHT_BRACE,"Expect '}' after block."),O}statement(){if(this.match(G.LEFT_BRACE))return new f(this.block());if(this.match(G.IF))return this.if_statement();if(this.match(G.PRINT))return this.print_statement();if(this.match(G.RETURN))return this.return_statement();if(this.match(G.WHILE))return this.while_statement();if(this.match(G.FOR))return this.for_statement();return this.expression_statement()}for_statement(){this.consume(G.LEFT_PAREN,"Expect '(' after 'for'.");let O;if(this.match(G.SEMICOLON))O=null;else if(this.match(G.VAR))O=this.var_declaration();else O=this.expression_statement();let Q=null;if(!this.check(G.SEMICOLON))Q=this.expression();this.consume(G.SEMICOLON,"Expect ';' after loop condition.");let $=null;if(!this.check(G.RIGHT_PAREN))$=this.expression();this.consume(G.RIGHT_PAREN,"Expect ')' after for clauses.");let U=this.statement();if($!==null)U=new f([U,new h($)]);if(Q===null)Q=new N(!0);if(U=new b(Q,U),O!==null)U=new f([O,U]);return U}return_statement(){let O=this.previous(),Q=null;if(!this.check(G.SEMICOLON))Q=this.expression();return this.consume(G.SEMICOLON,"Expect ';' after return value."),new l(O,Q)}while_statement(){this.consume(G.LEFT_PAREN,"Expect '(' after 'while'.");const O=this.expression();this.consume(G.RIGHT_PAREN,"Expect ')' after condition.");const Q=this.statement();return new b(O,Q)}if_statement(){this.consume(G.LEFT_PAREN,"Expect '(' after 'if'.");const O=this.expression();this.consume(G.RIGHT_PAREN,"Expect ')' after if condition.");const Q=this.statement();let $=null;if(this.match(G.ELSE))$=this.statement();return new a(O,Q,$)}print_statement(){let O=this.expression();return this.consume(G.SEMICOLON,"Expect ';' after value."),new m(O)}expression_statement(){const O=this.expression();return this.consume(G.SEMICOLON,"Expect ';' after expression."),new h(O)}equality(){let O=this.comparison();while(this.match(G.BANG_EQUAL,G.EQUAL_EQUAL)){let Q=this.previous(),$=this.comparison();O=new j(O,Q,$)}return O}comparison(){let O=this.term();while(this.match(G.GREATER,G.GREATER_EQUAL,G.LESS,G.LESS_EQUAL)){let Q=this.previous(),$=this.term();O=new j(O,Q,$)}return O}term(){let O=this.factor();while(this.match(G.MINUS,G.PLUS)){let Q=this.previous(),$=this.factor();O=new j(O,Q,$)}return O}factor(){let O=this.unary();while(this.match(G.SLASH,G.STAR)){let Q=this.previous(),$=this.unary();O=new j(O,Q,$)}return O}call(){let O=this.primary();while(!0)if(this.match(G.LEFT_PAREN))O=this.finish_call(O);else if(this.match(G.DOT)){const Q=this.consume(G.IDENTIFIER,"Expect property name after '.'.");O=new v(O,Q)}else break;return O}finish_call(O){let Q=[];if(!this.check(G.RIGHT_PAREN))do{if(Q.length>=255)return q.report(new Z(this.peek(),"Can't have more than 255 arguments."));Q.push(this.expression())}while(this.match(G.COMMA));let $=this.consume(G.RIGHT_PAREN,"Expect ')' after arguments.");return new QO(O,$,Q)}unary(){if(this.match(G.BANG,G.MINUS)){let O=this.previous(),Q=this.unary();return new t(O,Q)}return this.call()}primary(){if(this.match(G.FALSE))return new N(!1);if(this.match(G.TRUE))return new N(!0);if(this.match(G.NIL))return new N(null);if(this.match(G.THIS))return new r(this.previous());if(this.match(G.SUPER)){let O=this.previous();this.consume(G.DOT,"Expect '.' after 'super'.");let Q=this.consume(G.IDENTIFIER,"Expect superclass method name.");return new p(O,Q)}if(this.match(G.NUMBER,G.STRING))return new N(this.previous().literal);if(this.match(G.LEFT_PAREN)){let O=this.expression();return this.consume(G.RIGHT_PAREN,"Expect ')' after expression."),new e(O)}if(this.match(G.IDENTIFIER))return new E(this.previous());return q.report(new Z(this.peek(),"Expect expression."))}expression(){return this.assignment()}assignment(){let O=this.or();if(this.match(G.EQUAL)){let Q=this.previous(),$=this.assignment();if(O instanceof E){let U=O.name;return new OO(U,$)}else if(O instanceof v){let U=O;return new n(U.object,U.name,$)}q.report(new Z(Q,"Invalid assignment target."))}return O}or(){let O=this.and();while(this.match(G.OR)){let Q=this.previous(),$=this.and();O=new u(O,Q,$)}return O}and(){let O=this.equality();while(this.match(G.AND)){let Q=this.previous(),$=this.equality();O=new u(O,Q,$)}return O}consume(O,Q){if(this.check(O))return this.advance();return q.report(new Z(this.peek(),Q))}match(...O){for(let Q of O)if(this.check(Q))return this.advance(),!0;return!1}check(O){if(this.is_at_end())return!1;return this.peek().type===O}advance(){if(!this.is_at_end())this.current++;return this.previous()}previous(){return this.tokens[this.current-1]}peek(){return this.tokens[this.current]}is_at_end(){return this.peek().type==="EOF"}synchronize(){this.advance();while(this.is_at_end()){if(this.previous().type===G.SEMICOLON)return;switch(this.peek().type){case G.CLASS:case G.FUN:case G.VAR:case G.FOR:case G.IF:case G.WHILE:case G.PRINT:case G.RETURN:return}this.advance()}}}var w;(function(H){H["None"]="None";H["Function"]="Function";H["Initializer"]="Initializer";H["Method"]="Method"})(w||(w={}));var M;(function(U){U["None"]="None";U["Class"]="Class";U["SubClass"]="SubClass"})(M||(M={}));class SO extends Array{constructor(){super(...arguments)}is_empty(){return this.length<1}peek(){return this[this.length-1]}}class HO{O;scopes=new SO;currentFunction=w.None;currentClass=M.None;constructor(O){this.interpreter=O;this.interpreter=O}resolve(O){if(O instanceof Array)O.forEach((Q)=>this.resolve(Q));else O.accept(this)}resolve_local(O,Q){for(let $=this.scopes.length-1;$>=0;$--)if(this.scopes[$].has(Q.lexeme)){this.interpreter.resolve(O,this.scopes.length-1-$);return}}begin_scope(){this.scopes.push(new Map)}end_scope(){this.scopes.pop()}declare(O){if(this.scopes.is_empty())return;this.scopes.peek().set(O.lexeme,!1)}define(O){if(this.scopes.is_empty())return;this.scopes.peek().set(O.lexeme,!0)}resolve_function(O,Q){const $=this.currentFunction;this.currentFunction=Q,this.begin_scope(),O.params.forEach((U)=>{this.declare(U),this.define(U)}),this.resolve(O.body),this.end_scope(),this.currentFunction=$}visitClassStmt(O){const Q=this.currentClass;if(this.currentClass=M.Class,this.declare(O.name),this.define(O.name),O.superclass!==null)if(O.name.lexeme===O.superclass.name.lexeme)q.report(new SyntaxError("A class can't inherit from itself."));else this.currentClass=M.SubClass,this.resolve(O.superclass),this.begin_scope(),this.scopes.peek().set("super",!0);this.begin_scope(),this.scopes.peek().set("this",!0);for(let $ of O.methods){let U=w.Method;if($.name.lexeme==="init")U=w.Initializer;this.resolve_function($,U)}if(this.end_scope(),O.superclass!==null)this.end_scope();this.currentClass=Q}visitBlockStmt(O){this.begin_scope(),this.resolve(O.statements),this.end_scope()}visitVarStmt(O){if(this.declare(O.name),O.initializer!==null)this.resolve(O.initializer);this.define(O.name)}visitVariableExpr(O){if(!this.scopes.is_empty()&&this.scopes.peek().get(O.name.lexeme)===!1)q.report(new P(O.name,"Cannot read local variable in its own initializer."));this.resolve_local(O,O.name)}visitAssignExpr(O){this.resolve(O.value),this.resolve_local(O,O.name)}visitSuperExpr(O){if(this.currentClass===M.None)q.report(new P(O.keyword,"Cannot use 'super' outside of a class."));else if(this.currentClass!==M.SubClass)q.report(new P(O.keyword,"Cannot use 'super' in a class with no superclass."));this.resolve_local(O,O.keyword)}visitFunctionStmt(O){this.declare(O.name),this.define(O.name),this.resolve_function(O,w.Function)}visitExpressionStmt(O){this.resolve(O.expression)}visitIfStmt(O){if(this.resolve(O.condition),this.resolve(O.thenBranch),O.elseBranch!==null)this.resolve(O.elseBranch)}visitPrintStmt(O){this.resolve(O.expression)}visitReturnStmt(O){if(O.value!==null){if(this.currentFunction===w.Initializer)q.report(new P(O.keyword,"Cannot return a value from an initializer."));if(this.currentFunction===w.None)q.report(new P(O.keyword,"Cannot return from top-level code."));this.resolve(O.value)}}visitWhileStmt(O){this.resolve(O.condition),this.resolve(O.body)}visitForStmt(O){if(O.initializer!==null)this.resolve(O.initializer);if(O.condition!==null)this.resolve(O.condition);if(O.increment!==null)this.resolve(O.increment)}visitBinaryExpr(O){this.resolve(O.left),this.resolve(O.right)}visitCallExpr(O){this.resolve(O.callee),O.args.forEach((Q)=>this.resolve(Q))}visitGroupingExpr(O){this.resolve(O.expression)}visitLiteralExpr(O){}visitUnaryExpr(O){this.resolve(O.right)}visitLogicalExpr(O){this.resolve(O.left),this.resolve(O.right)}visitSetExpr(O){this.resolve(O.value),this.resolve(O.object)}visitGetExpr(O){this.resolve(O.object)}visitThisExpr(O){if(this.currentClass===M.None){q.report(new P(O.keyword,"Cannot use 'this' outside of a class."));return}this.resolve_local(O,O.keyword)}}class g{type;lexeme;literal;line;constructor(O,Q,$,U){this.type=O,this.lexeme=Q,this.literal=$,this.line=U}to_string(){return`${this.type} ${this.lexeme} ${this.literal}`}}class qO{logger=new y;tokens;source;current=0;start=0;line=1;constructor(){this.source="",this.tokens=[],this.current=0,this.start=0,this.line=1}add_source(O){this.source+=O,this.current=0,this.start=0,this.line=1}set_source(O){this.source=O}reset_scanner(){this.source="",this.current=0,this.start=0,this.line=1}scan_tokens(){while(!this.is_end())this.start=this.current,this.scan();this.tokens.push(new g(G.EOF,"",null,this.line))}is_end(){return this.current>=this.source.length}advance(){return this.source.charAt(this.current++)}match(O){if(this.is_end())return!1;if(this.source.charAt(this.current)!==O)return!1;return this.current++,!0}add_token(O,Q){let $=this.source.substring(this.start,this.current),U=new g(O,$,Q,this.line);this.tokens.push(U)}peek(){return this.source.charAt(this.current)}current_char(){return this.source.charAt(this.current-1)}is_digit(O){return O>="0"&&O<="9"}is_alpha(O){return O>="a"&&O<="z"||O>="A"&&O<="Z"||O==="_"}is_alpha_numeric(O){return this.is_alpha(O)||this.is_digit(O)}identifier(){while(this.is_alpha_numeric(this.peek()))this.advance();let O=this.source.substring(this.start,this.current);const Q=AO[O];if(Q!==void 0)this.add_token(Q,null);else this.add_token(G.IDENTIFIER,null)}string(){while(this.peek()!=='"'&&!this.is_end()){if(this.peek()==="\n")this.line++;this.advance()}if(this.is_end())q.report(new Z(null,"Unterminated string.at line "+this.line+" column "+this.current+""));this.advance();let O=this.source.substring(this.start+1,this.current-1);this.add_token(G.STRING,O)}number(){while(this.is_digit(this.peek()))this.advance();if(this.peek()==="."&&this.is_digit(this.peek()))this.advance();let O=this.source.substring(this.start,this.current),Q=parseFloat(O);this.add_token(G.NUMBER,Q)}scan(){let O=this.advance();switch(O){case"{":this.add_token(G.LEFT_BRACE,null);break;case"}":this.add_token(G.RIGHT_BRACE,null);break;case"(":this.add_token(G.LEFT_PAREN,null);break;case")":this.add_token(G.RIGHT_PAREN,null);break;case"\u2795":case"+":this.add_token(G.PLUS,null);break;case"\u2796":case"-":this.add_token(G.MINUS,null);break;case"\u2716":case"\u274C":case"*":this.add_token(G.STAR,null);break;case"\u2797":case"/":if(this.match("/"))while(this.peek()!="\n"&&!this.is_end())this.advance();else this.add_token(G.SLASH,null);break;case"\u2714":this.add_token(G.EQUAL_EQUAL,null);break;case"=":this.add_token(this.match("=")?G.EQUAL_EQUAL:G.EQUAL,null);break;case"o":if(this.match("r"))this.add_token(G.OR,null);break;case",":this.add_token(G.COMMA,null);break;case".":this.add_token(G.DOT,null);break;case"\u2757":this.add_token(G.BANG_EQUAL,null);break;case"!":this.add_token(this.match("=")?G.BANG_EQUAL:G.BANG,null);break;case"\u2B05":this.add_token(G.LESS_EQUAL,null);break;case"<":this.add_token(this.match("=")?G.LESS_EQUAL:G.LESS,null);break;case"\u27A1":this.add_token(G.GREATER_EQUAL,null);break;case">":this.add_token(this.match("=")?G.GREATER_EQUAL:G.GREATER,null);break;case"\n":this.line++;break;case"\t":break;case'"':this.string();break;case" ":case"\r":break;case";":this.add_token(G.SEMICOLON,null);break;default:if(this.is_digit(O))this.number();else if(this.is_alpha(O))this.identifier();else q.report(new Z(null,"Unexpected character."));break}}get_tokens(){return this.tokens}print_tokens(){this.logger.info(this.tokens)}}class DO{interpreter;resolver;astPrinter;parser;scanner;MODE;constructor(){this.scanner=new qO,this.interpreter=new UO,this.resolver=new HO(this.interpreter),this.parser=new WO([]),this.astPrinter=new $O,Bun.argv[2]===void 0?this.MODE="REPL":this.MODE="FILE"}run(){if(this.MODE==="FILE")IO((O)=>{this.scanner.set_source(O),this.scanner.scan_tokens();const Q=this.scanner.get_tokens();this.parser.set_tokens(Q);const $=this.parser.parse();this.resolver.resolve($),this.print_ast($),console.log(L.blue("                                                 ")),console.log(L.blue("================      Compiled Output       ================")),console.log(L.blue("                                                 ")),this.interpreter.interpret($)});else console.log("REPL is still in progress\n"),console.log("Usage: beer [script]")}print_ast(O){console.log(L.cyan("================      AST       ================")),console.log(L.cyan("                                                 ")),this.astPrinter.print_ast(O)}}var dO=new DO;dO.run();
