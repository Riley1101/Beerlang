#!/usr/bin/env bun
// @bun
var FO=function(){const O=new Map;for(let[U,$]of Object.entries(D)){for(let[W,H]of Object.entries($))D[W]={open:`\x1B[${H[0]}m`,close:`\x1B[${H[1]}m`},$[W]=D[W],O.set(H[0],H[1]);Object.defineProperty(D,U,{value:$,enumerable:!1})}return Object.defineProperty(D,"codes",{value:O,enumerable:!1}),D.color.close="\x1B[39m",D.bgColor.close="\x1B[49m",D.color.ansi=KO(),D.color.ansi256=XO(),D.color.ansi16m=ZO(),D.bgColor.ansi=KO(10),D.bgColor.ansi256=XO(10),D.bgColor.ansi16m=ZO(10),Object.defineProperties(D,{rgbToAnsi256:{value(U,$,W){if(U===$&&$===W){if(U<8)return 16;if(U>248)return 231;return Math.round((U-8)/247*24)+232}return 16+36*Math.round(U/255*5)+6*Math.round($/255*5)+Math.round(W/255*5)},enumerable:!1},hexToRgb:{value(U){const $=/[a-f\d]{6}|[a-f\d]{3}/i.exec(U.toString(16));if(!$)return[0,0,0];let[W]=$;if(W.length===3)W=[...W].map((J)=>J+J).join("");const H=Number.parseInt(W,16);return[H>>16&255,H>>8&255,H&255]},enumerable:!1},hexToAnsi256:{value:(U)=>D.rgbToAnsi256(...D.hexToRgb(U)),enumerable:!1},ansi256ToAnsi:{value(U){if(U<8)return 30+U;if(U<16)return 90+(U-8);let $,W,H;if(U>=232)$=((U-232)*10+8)/255,W=$,H=$;else{U-=16;const JO=U%36;$=Math.floor(U/36)/5,W=Math.floor(JO/6)/5,H=JO%6/5}const J=Math.max($,W,H)*2;if(J===0)return 30;let K=30+(Math.round(H)<<2|Math.round(W)<<1|Math.round($));if(J===2)K+=60;return K},enumerable:!1},rgbToAnsi:{value:(U,$,W)=>D.ansi256ToAnsi(D.rgbToAnsi256(U,$,W)),enumerable:!1},hexToAnsi:{value:(U)=>D.ansi256ToAnsi(D.hexToAnsi256(U)),enumerable:!1}}),D};var KO=(O=0)=>(U)=>`\x1B[${U+O}m`,XO=(O=0)=>(U)=>`\x1B[${38+O};5;${U}m`,ZO=(O=0)=>(U,$,W)=>`\x1B[${38+O};2;${U};${$};${W}m`,D={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgGray:[100,49],bgGrey:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}},gO=Object.keys(D.modifier),jO=Object.keys(D.color),EO=Object.keys(D.bgColor),cO=[...jO,...EO],BO=FO(),X=BO;var C=(()=>{if(navigator.userAgentData){const O=navigator.userAgentData.brands.find(({brand:U})=>U==="Chromium");if(O&&O.version>93)return 3}if(/\b(Chrome|Chromium)\//.test(navigator.userAgent))return 1;return 0})(),PO=C!==0&&{level:C,hasBasic:!0,has256:C>=2,has16m:C>=3},_O={stdout:PO,stderr:PO},LO=_O;function wO(O,U,$){let W=O.indexOf(U);if(W===-1)return O;const H=U.length;let J=0,K="";do K+=O.slice(J,W)+U+$,J=W+H,W=O.indexOf(U,J);while(W!==-1);return K+=O.slice(J),K}function VO(O,U,$,W){let H=0,J="";do{const K=O[W-1]==="\r";J+=O.slice(H,K?W-1:W)+U+(K?"\r\n":"\n")+$,H=W+1,W=O.indexOf("\n",H)}while(W!==-1);return J+=O.slice(H),J}var _=function(O){return CO(O)};var{stdout:MO,stderr:NO}=LO,c=Symbol("GENERATOR"),z=Symbol("STYLER"),B=Symbol("IS_EMPTY"),YO=["ansi","ansi","ansi256","ansi16m"],S=Object.create(null),fO=(O,U={})=>{if(U.level&&!(Number.isInteger(U.level)&&U.level>=0&&U.level<=3))throw new Error("The `level` option should be an integer from 0 to 3");const $=MO?MO.level:0;O.level=U.level===void 0?$:U.level};var CO=(O)=>{const U=(...$)=>$.join(" ");return fO(U,O),Object.setPrototypeOf(U,_.prototype),U};Object.setPrototypeOf(_.prototype,Function.prototype);for(let[O,U]of Object.entries(X))S[O]={get(){const $=R(this,k(U.open,U.close,this[z]),this[B]);return Object.defineProperty(this,O,{value:$}),$}};S.visible={get(){const O=R(this,this[z],!0);return Object.defineProperty(this,"visible",{value:O}),O}};var x=(O,U,$,...W)=>{if(O==="rgb"){if(U==="ansi16m")return X[$].ansi16m(...W);if(U==="ansi256")return X[$].ansi256(X.rgbToAnsi256(...W));return X[$].ansi(X.rgbToAnsi(...W))}if(O==="hex")return x("rgb",U,$,...X.hexToRgb(...W));return X[$][O](...W)},RO=["rgb","hex","ansi256"];for(let O of RO){S[O]={get(){const{level:$}=this;return function(...W){const H=k(x(O,YO[$],"color",...W),X.color.close,this[z]);return R(this,H,this[B])}}};const U="bg"+O[0].toUpperCase()+O.slice(1);S[U]={get(){const{level:$}=this;return function(...W){const H=k(x(O,YO[$],"bgColor",...W),X.bgColor.close,this[z]);return R(this,H,this[B])}}}}var hO=Object.defineProperties(()=>{},{...S,level:{enumerable:!0,get(){return this[c].level},set(O){this[c].level=O}}}),k=(O,U,$)=>{let W,H;if($===void 0)W=O,H=U;else W=$.openAll+O,H=U+$.closeAll;return{open:O,close:U,openAll:W,closeAll:H,parent:$}},R=(O,U,$)=>{const W=(...H)=>bO(W,H.length===1?""+H[0]:H.join(" "));return Object.setPrototypeOf(W,hO),W[c]=O,W[z]=U,W[B]=$,W},bO=(O,U)=>{if(O.level<=0||!U)return O[B]?"":U;let $=O[z];if($===void 0)return U;const{openAll:W,closeAll:H}=$;if(U.includes("\x1B"))while($!==void 0)U=wO(U,$.close,$.open),$=$.parent;const J=U.indexOf("\n");if(J!==-1)U=VO(U,H,W,J);return W+U+H};Object.defineProperties(_.prototype,S);var vO=_(),lO=_({level:NO?NO.level:0});var L=vO;function IO(O){const $=Bun.argv[2];if($===void 0)console.log("Usage: beer [script]"),process.exit(64);const W=Bun.file($);if(!/(\.beer)$/g.test(W.name))console.log("File must have .beer extension"),process.exit(64);W.text().then((K)=>{O(K)})}var A=L;class m{_log;constructor(){this._log=A}info(O){if(typeof O==="object")O=JSON.stringify(O,null,2);console.log(this._log.blue(O))}error(O){if(typeof O==="object")O=JSON.stringify(O,null,2);console.log(this._log.red(O))}warn(O){if(typeof O==="object")O=JSON.stringify(O,null,2);console.log(this._log.yellow(O))}debug(O){if(typeof O==="object")O=JSON.stringify(O,null,2);console.log(this._log.green(O))}}class y extends Error{constructor(O){super(O);this.name="ClientError"}}class P extends Error{token;constructor(O,U){super(U);this.token=O,this.name="RuntimeError"}}class Z extends Error{token;constructor(O,U){super(U);this.token=O,this.name="SyntaxError"}}class zO{hasCliError=!1;hasRuntimeError=!1;hasSyntaxError=!1;log(O){if(O instanceof y)console.log(A.red(O.message));else if(O instanceof P)console.log(A.red(O.message));else console.log(A.red(O.message))}report(O){if(O instanceof y)this.hasCliError=!0;else if(O instanceof P)this.hasRuntimeError=!0;else this.hasSyntaxError=!0;throw this.log(O),O}}var q=new zO;class f{O;constructor(O){this.statements=O;this.statements=O}accept(O){return O.visitBlockStmt(this)}}class h{O;constructor(O){this.expression=O;this.expression=O}accept(O){return O.visitExpressionStmt(this)}}class i{O;constructor(O){this.expression=O;this.expression=O}accept(O){return O.visitPrintStmt(this)}}class a{O;U;$;constructor(O,U,$){this.condition=O;this.thenBranch=U;this.elseBranch=$;this.condition=O,this.thenBranch=U,this.elseBranch=$}accept(O){return O.visitIfStmt(this)}}class b{O;U;constructor(O,U){this.condition=O;this.body=U;this.condition=O,this.body=U}accept(O){return O.visitWhileStmt(this)}}class l{O;U;constructor(O,U){this.keyword=O;this.value=U;this.keyword=O,this.value=U}accept(O){return O.visitReturnStmt(this)}}class T{O;U;$;constructor(O,U,$){this.name=O;this.params=U;this.body=$;this.name=O,this.params=U,this.body=$}accept(O){return O.visitFunctionStmt(this)}}class p{O;U;constructor(O,U){this.keyword=O;this.method=U;this.keyword=O,this.method=U}accept(O){return O.visitSuperExpr(this)}}class o{O;U;$;constructor(O,U,$){this.name=O;this.superclass=U;this.methods=$;this.name=O,this.superclass=U,this.methods=$}accept(O){return O.visitClassStmt(this)}}class s{O;U;constructor(O,U){this.name=O;this.initializer=U;this.name=O,this.initializer=U}accept(O){return O.visitVarStmt(this)}}class n{O;U;$;constructor(O,U,$){this.object=O;this.name=U;this.value=$;this.object=O,this.name=U,this.value=$}accept(O){return O.visitSetExpr(this)}}class r{O;constructor(O){this.keyword=O;this.keyword=O}accept(O){return O.visitThisExpr(this)}}class v{O;U;constructor(O,U){this.object=O;this.name=U;this.object=O,this.name=U}accept(O){return O.visitGetExpr(this)}}class j{left;operator;right;constructor(O,U,$){this.left=O,this.operator=U,this.right=$}accept(O){return O.visitBinaryExpr(this)}}class t{operator;right;constructor(O,U){this.operator=O,this.right=U}accept(O){return O.visitUnaryExpr(this)}}class N{value;constructor(O){this.value=O}accept(O){return O.visitLiteralExpr(this)}}class e{expression;constructor(O){this.expression=O}accept(O){return O.visitGroupingExpr(this)}}class E{O;constructor(O){this.name=O;this.name=O}accept(O){return O.visitVariableExpr(this)}}class OO{O;U;constructor(O,U){this.name=O;this.value=U;this.name=O,this.value=U}accept(O){return O.visitAssignExpr(this)}}class UO{O;U;$;constructor(O,U,$){this.callee=O;this.paren=U;this.args=$;this.callee=O,this.paren=U,this.args=$}accept(O){return O.visitCallExpr(this)}}class u{O;U;$;constructor(O,U,$){this.left=O;this.operator=U;this.right=$;this.left=O,this.operator=U,this.right=$}accept(O){return O.visitLogicalExpr(this)}}class $O{visitSetExpr(O){return this.parenthesize(`set ${O.name.lexeme}`,O.value)}visitGetExpr(O){return this.parenthesize(`get ${O.name.lexeme}`,O.object)}visitAssignExpr(O){return this.parenthesize(O.name.lexeme,O.value)}visitBinaryExpr(O){return this.parenthesize(O.operator.lexeme,O.left,O.right)}visitUnaryExpr(O){return this.parenthesize(O.operator.lexeme,O.right)}visitLiteralExpr(O){if(O.value===null)return"nil";return O.value.toString()}visitLogicalExpr(O){return this.parenthesize(O.operator.lexeme,O.left,O.right)}visitExpressionStmt(O){return this.parenthesize("expression",O.expression)}visitPrintStmt(O){return this.parenthesize("print",O.expression)}visitVarStmt(O){const U=new E(O.name);if(O.initializer)return this.parenthesize("var",U,O.initializer);return this.parenthesize("var",U)}visitBlockStmt(O){let U="(block ";for(let $ of O.statements)U+="\n"+this.indent($.accept(this));return U+=")",U}visitForStmt(O){let U=`(for ${this.stringify(O.initializer)} ${this.stringify(O.condition)} ${this.stringify(O.increment)}\n`;const $=this.stringify(O.body);return U+=this.indent($),U+=")",U}visitWhileStmt(O){let U=`(while ${this.stringify(O.condition)}\n`;const $=this.stringify(O.body);return U+=this.indent($),U+=")",U}visitReturnStmt(O){if(O.value)return this.parenthesize("return",O.value);return this.parenthesize("return")}visitFunctionStmt(O){let U=`(fun ${O.name.lexeme} (`;for(let W of O.params)U+=W.lexeme+" ";U+=")\n";const $=this.stringify(O.body);return U+=this.indent($),U+=")",U}visitClassStmt(O){let U=`(class ${O.name.lexeme}`;return O.methods.forEach(($)=>{U+="\n"+this.indent(this.stringify($))}),U+=")",U}visitIfStmt(O){let U=`(if ${this.stringify(O.condition)}\n`;const $=this.stringify(O.thenBranch);if(U+=this.indent($),O.elseBranch!==null){U+="\n";const W=this.stringify(O.elseBranch);U+=this.indent(W)}return U+=")",U}visitVariableExpr(O){return O.name.lexeme}visitGroupingExpr(O){return this.parenthesize("group",O.expression)}visitThisExpr(O){return O.keyword.lexeme}visitCallExpr(O){return this.parenthesize("call",O.callee,...O.args)}visitSuperExpr(O){return O.keyword.lexeme}parenthesize(O,...U){let $=`(${O}`;for(let W of U)$+=` ${W.accept(this)}`;return $+=")",$}indent(O){return O.split("\n").map((U)=>`  ${U}`).join("\n")}print(O){return O.accept(this)}stringify(O){if(O===null)return"nil";if(O instanceof Array)return O.map((U)=>U.accept(this)).join("\n");else return O.accept(this)}print_ast(O){console.log(A.cyan(this.stringify(O)))}generate_ast(O){return this.stringify(O).split("\n")}}class w{enclosing;values=new Map;constructor(O){if(this.enclosing=null,O)this.enclosing=O}define(O,U){this.values.set(O,U)}get(O){if(this.values.has(O))return this.values.get(O);if(this.enclosing!==null)return this.enclosing.get(O);return q.report(new ReferenceError(`Undefined variable '${O}'`))}assign(O,U){if(this.values.has(O)){this.values.set(O,U);return}if(this.enclosing!==null){this.enclosing.assign(O,U);return}return q.report(new ReferenceError(`Undefined variable '${O}'`))}ancestor(O){let U=this;for(let $=0;$<O;$++)U=U.enclosing;return U}get_at(O,U){return this.ancestor(O).values.get(U)}assign_at(O,U,$){this.ancestor(O).values.set(U,$)}}var Q;(function(G){G["LEFT_PAREN"]="LEFT_PAREN";G["RIGHT_PAREN"]="RIGHT_PAREN";G["LEFT_BRACE"]="LEFT_BRACE";G["RIGHT_BRACE"]="RIGHT_BRACE";G["LEFT_BRACKET"]="LEFT_BRACKET";G["RIGHT_BRACKET"]="RIGHT_BRACKET";G["COMMA"]="COMMA";G["DOT"]="DOT";G["MINUS"]="MINUS";G["PLUS"]="PLUS";G["MODULO"]="MODULO";G["SEMICOLON"]="SEMICOLON";G["SLASH"]="SLASH";G["STAR"]="STAR";G["BANG"]="BANG";G["BANG_EQUAL"]="BANG_EQUAL";G["EQUAL"]="EQUAL";G["EQUAL_EQUAL"]="EQUAL_EQUAL";G["GREATER"]="GREATER";G["GREATER_EQUAL"]="GREATER_EQUAL";G["LESS"]="LESS";G["LESS_EQUAL"]="LESS_EQUAL";G["IDENTIFIER"]="IDENTIFIER";G["STRING"]="STRING";G["NUMBER"]="NUMBER";G["AND"]="AND";G["CLASS"]="CLASS";G["ELSE"]="ELSE";G["FALSE"]="FALSE";G["FUN"]="FUN";G["FOR"]="FOR";G["IF"]="IF";G["NIL"]="NIL";G["OR"]="OR";G["PRINT"]="PRINT";G["RETURN"]="RETURN";G["SUPER"]="SUPER";G["THIS"]="THIS";G["TRUE"]="TRUE";G["VAR"]="VAR";G["WHILE"]="WHILE";G["EOF"]="EOF"})(Q||(Q={}));var SO={and:Q.AND,class:Q.CLASS,else:Q.ELSE,false:Q.FALSE,for:Q.FOR,fun:Q.FUN,if:Q.IF,nil:Q.NIL,or:Q.OR,print:Q.PRINT,return:Q.RETURN,super:Q.SUPER,this:Q.THIS,true:Q.TRUE,var:Q.VAR,while:Q.WHILE};class I{}class Y extends I{O;U;$;static Return=class O{value;constructor(U){this.value=U}};constructor(O,U,$=!1){super();this.declaration=O;this.closure=U;this.is_initializer=$;this.declaration=O,this.closure=U,this.is_initializer=$}to_string(){return`<fun ${this.declaration.name.lexeme}>`}arity(){return this.declaration.params.length}bind(O){let U=new w(this.closure);return U.define("this",O),new Y(this.declaration,U,this.is_initializer)}call(O,U){const $=new w(this.closure);for(let W=0;W<this.declaration.params.length;W++)$.define(this.declaration.params[W].lexeme,U[W]);try{O.execute_block(this.declaration.body,$)}catch(W){if(W instanceof Y.Return){if(this.is_initializer)return this.closure.get_at(0,"this");return W.value}throw W}if(this.is_initializer)return this.closure.get_at(0,"this");return null}}class QO extends I{constructor(){super(...arguments)}arity(){return 0}call(){return Date.now().valueOf()/1000}to_string(){return"<native fn>"}}class d extends I{U;$;name;constructor(O,U,$){super();this.methods=U;this.superclass=$;this.name=O,this.methods=U,this.superclass=$}find_method(O){if(this.methods.has(O))return this.methods.get(O);if(this.superclass!==null)return this.superclass.find_method(O);return null}arity(){const O=this.find_method("init");if(O===null)return 0;return O.arity()}call(O,U){let $=new F(this);const W=this.find_method("init");if(W!==null)W.bind($).call(O,U);return $}to_string(){return`<class ${this.name}>`}}class F{O;fields=new Map;constructor(O){this.klass=O;this.klass=O}get(O){if(this.fields.has(O.lexeme))return this.fields.get(O.lexeme);let U=this.klass.find_method(O.lexeme);if(U)return U.bind(this);return q.report(new SyntaxError(`Undefined property '${O.lexeme}'.`))}set(O,U){this.fields.set(O.lexeme,U)}to_string(){return`<instance ${this.klass.name}>`}}class WO{globals=new w;environment=this.globals;locals=new Map;constructor(){this.globals.define("clock",new QO)}resolve(O,U){this.locals.set(O,U)}look_up_variable(O,U){const $=this.locals.get(U);if($!==void 0)return this.environment.get_at($,O.lexeme);else return this.globals.get(O.lexeme)}interpret(O){try{for(let U of O)this.execute(U)}catch(U){throw U}}execute(O){O.accept(this)}evaluate(O){return O.accept(this)}is_equal(O,U){if(O===null&&U===null)return!0;if(O===null)return!1;return O===U}checkNumberOperands(O,U,$){if(typeof U==="number"&&typeof $==="number")return;else q.report(new SyntaxError("Operands must be numbers at "+O.line+O.lexeme))}is_truthy(O){if(O===null)return!1;if(typeof O==="boolean")return O;return!0}stringify(O){if(O===null)return"nil";if(typeof O==="number")return O.toString();if(O instanceof I)return O.to_string();if(O instanceof F)return O.to_string();return O.toString()}execute_block(O,U){const $=this.environment;try{this.environment=U;for(let W of O)W&&this.execute(W)}finally{this.environment=$}}visitThisExpr(O){return this.look_up_variable(O.keyword,O)}visitAssignExpr(O){let U=this.evaluate(O.value),$=this.locals.get(O);if($!==void 0)this.environment.assign_at($,O.name.lexeme,U);else this.globals.assign(O.name.lexeme,U);return U}visitBinaryExpr(O){let U=this.evaluate(O.left),$=this.evaluate(O.right);switch(O.operator.type){case Q.GREATER:return this.checkNumberOperands(O.operator,U,$),U>$;case Q.GREATER_EQUAL:return this.checkNumberOperands(O.operator,U,$),U>=$;case Q.LESS:return this.checkNumberOperands(O.operator,U,$),U<$;case Q.LESS_EQUAL:return this.checkNumberOperands(O.operator,U,$),U<=$;case Q.MINUS:return this.checkNumberOperands(O.operator,U,$),U-$;case Q.BANG_EQUAL:return!this.is_equal(U,$);case Q.EQUAL_EQUAL:return this.is_equal(U,$);case Q.SLASH:if(this.checkNumberOperands(O.operator,U,$),$===0)q.report(new Error("Division by zero at  line "+O.operator.line+O.operator.lexeme));return U/$;case Q.STAR:return this.checkNumberOperands(O.operator,U,$),U*$;case Q.PLUS:if(typeof U==="number"&&typeof $==="number")return U+$;if(typeof U==="string"&&typeof $==="string")return U+$;q.report(new SyntaxError("Operands must be two numbers or two strings at "+O.operator.line+O.operator.lexeme))}return null}visitUnaryExpr(O){let U=this.evaluate(O.right);switch(O.operator.type){case Q.MINUS:return-U;case Q.BANG:return!this.is_truthy(U)}return null}visitLiteralExpr(O){return O.value}visitGroupingExpr(O){return this.evaluate(O.expression)}visitVariableExpr(O){return this.look_up_variable(O.name,O)}visitLogicalExpr(O){let U=this.evaluate(O.left);if(O.operator.type===Q.OR){if(this.is_truthy(U))return U}else if(!this.is_truthy(U))return U;return this.evaluate(O.right)}visitCallExpr(O){let U=this.evaluate(O.callee),$=[];for(let H of O.args)$.push(this.evaluate(H));if(!(U instanceof I))throw q.report(new SyntaxError("Can only call functions and classes."));if($.length!==U.arity())throw q.report(new SyntaxError(`Expected ${U.arity()} arguments but got ${$.length}.`));return U.call(this,$)}visitClassStmt(O){let U=null;if(O.superclass!==null){if(U=this.evaluate(O.superclass),!(U instanceof d))throw q.report(new SyntaxError("Superclass must be a class."))}if(this.environment.define(O.name.lexeme,null),O.superclass!==null)this.environment=new w(this.environment),this.environment.define("super",U);let $=new Map;for(let H of O.methods){let J=new Y(H,this.environment,H.name.lexeme==="init");$.set(H.name.lexeme,J)}let W=new d(O.name.lexeme,$,U);if(U!==null)this.environment=this.environment.enclosing;this.environment.assign(O.name.lexeme,W)}visitForStmt(O){if(O.initializer)this.execute(O.initializer);while(this.is_truthy(this.evaluate(O.condition))){if(this.execute(O.body),O.increment===null)return;this.evaluate(O.increment)}}visitWhileStmt(O){while(this.is_truthy(this.evaluate(O.condition)))this.execute(O.body)}visitReturnStmt(O){let U=null;if(O.value!==null)U=this.evaluate(O.value);throw new Y.Return(U)}visitFunctionStmt(O){let U=new Y(O,this.environment,!1);this.environment.define(O.name.lexeme,U);return}visitPrintStmt(O){let U=this.evaluate(O.expression);console.log(this.stringify(U))}visitExpressionStmt(O){this.evaluate(O.expression)}visitVarStmt(O){let U=null;if(O.initializer!==null)U=this.evaluate(O.initializer);this.environment.define(O.name.lexeme,U)}visitBlockStmt(O){this.execute_block(O.statements,new w(this.environment))}visitIfStmt(O){if(this.is_truthy(this.evaluate(O.condition)))this.execute(O.thenBranch);else if(O.elseBranch!==null)this.execute(O.elseBranch)}visitGetExpr(O){let U=this.evaluate(O.object);if(U instanceof F)return U.get(O.name);throw q.report(new SyntaxError("Only instances have properties."))}visitSetExpr(O){let U=this.evaluate(O.object);if(!(U instanceof F))throw q.report(new SyntaxError("Only instances have fields."));let $=this.evaluate(O.value);return U.set(O.name,$),$}visitSuperExpr(O){let U=this.locals.get(O),$=this.environment.get_at(U,"super"),W=this.environment.get_at(U-1,"this"),H=$.find_method(O.method.lexeme);if(H===null)throw q.report(new SyntaxError(`Undefined property '${O.method.lexeme}'.`));return H.bind(W)}}class GO{tokens;current;constructor(O){this.tokens=O,this.current=0}reset_parser(){this.current=0,this.tokens=[]}set_tokens(O){this.tokens=O}parse(){const O=[];while(!this.is_at_end())try{O.push(this.declaration())}catch(U){if(U instanceof Z)throw q.report(U);this.synchronize()}return O}class_declaration(){let O=this.consume(Q.IDENTIFIER,"Expect class name."),U=null;if(this.match(Q.LESS))this.consume(Q.IDENTIFIER,"Expect superclass name."),U=new E(this.previous());this.consume(Q.LEFT_BRACE,"Expect '{' before class body.");let $=[];while(!this.check(Q.RIGHT_BRACE)&&!this.is_at_end())$.push(this.function_declaration("method"));return this.consume(Q.RIGHT_BRACE,"Expect '}' after class body."),new o(O,U,$)}function_declaration(O){let U=this.consume(Q.IDENTIFIER,`Expect ${O} name.`);this.consume(Q.LEFT_PAREN,`Expect '(' after ${O} name.`);const $=[];if(!this.check(Q.RIGHT_PAREN))do{if($.length>=255)q.report(new Z(this.peek(),"Cannot have more than 255 parameters."));$.push(this.consume(Q.IDENTIFIER,"Expect parameter name."))}while(this.match(Q.COMMA));this.consume(Q.RIGHT_PAREN,"Expect ')' after parameters."),this.consume(Q.LEFT_BRACE,`Expect '{' before ${O} body.`);const W=this.block();return new T(U,$,W)}declaration(){if(this.match(Q.CLASS))return this.class_declaration();if(this.match(Q.FUN))return this.function_declaration("function");if(this.match(Q.VAR))return this.var_declaration();return this.statement()}var_declaration(){const O=this.consume(Q.IDENTIFIER,"Expect variable name.");let U=null;if(this.match(Q.EQUAL))U=this.expression();return this.consume(Q.SEMICOLON,"Expect ';' after variable declaration."),new s(O,U)}block(){const O=[];while(!this.check(Q.RIGHT_BRACE)&&!this.is_at_end())O.push(this.declaration());return this.consume(Q.RIGHT_BRACE,"Expect '}' after block."),O}statement(){if(this.match(Q.LEFT_BRACE))return new f(this.block());if(this.match(Q.IF))return this.if_statement();if(this.match(Q.PRINT))return this.print_statement();if(this.match(Q.RETURN))return this.return_statement();if(this.match(Q.WHILE))return this.while_statement();if(this.match(Q.FOR))return this.for_statement();return this.expression_statement()}for_statement(){this.consume(Q.LEFT_PAREN,"Expect '(' after 'for'.");let O;if(this.match(Q.SEMICOLON))O=null;else if(this.match(Q.VAR))O=this.var_declaration();else O=this.expression_statement();let U=null;if(!this.check(Q.SEMICOLON))U=this.expression();this.consume(Q.SEMICOLON,"Expect ';' after loop condition.");let $=null;if(!this.check(Q.RIGHT_PAREN))$=this.expression();this.consume(Q.RIGHT_PAREN,"Expect ')' after for clauses.");let W=this.statement();if($!==null)W=new f([W,new h($)]);if(U===null)U=new N(!0);if(W=new b(U,W),O!==null)W=new f([O,W]);return W}return_statement(){let O=this.previous(),U=null;if(!this.check(Q.SEMICOLON))U=this.expression();return this.consume(Q.SEMICOLON,"Expect ';' after return value."),new l(O,U)}while_statement(){this.consume(Q.LEFT_PAREN,"Expect '(' after 'while'.");const O=this.expression();this.consume(Q.RIGHT_PAREN,"Expect ')' after condition.");const U=this.statement();return new b(O,U)}if_statement(){this.consume(Q.LEFT_PAREN,"Expect '(' after 'if'.");const O=this.expression();this.consume(Q.RIGHT_PAREN,"Expect ')' after if condition.");const U=this.statement();let $=null;if(this.match(Q.ELSE))$=this.statement();return new a(O,U,$)}print_statement(){let O=this.expression();return this.consume(Q.SEMICOLON,"Expect ';' after value."),new i(O)}expression_statement(){const O=this.expression();return this.consume(Q.SEMICOLON,"Expect ';' after expression."),new h(O)}equality(){let O=this.comparison();while(this.match(Q.BANG_EQUAL,Q.EQUAL_EQUAL)){let U=this.previous(),$=this.comparison();O=new j(O,U,$)}return O}comparison(){let O=this.term();while(this.match(Q.GREATER,Q.GREATER_EQUAL,Q.LESS,Q.LESS_EQUAL)){let U=this.previous(),$=this.term();O=new j(O,U,$)}return O}term(){let O=this.factor();while(this.match(Q.MINUS,Q.PLUS)){let U=this.previous(),$=this.factor();O=new j(O,U,$)}return O}factor(){let O=this.unary();while(this.match(Q.SLASH,Q.STAR)){let U=this.previous(),$=this.unary();O=new j(O,U,$)}return O}call(){let O=this.primary();while(!0)if(this.match(Q.LEFT_PAREN))O=this.finish_call(O);else if(this.match(Q.DOT)){const U=this.consume(Q.IDENTIFIER,"Expect property name after '.'.");O=new v(O,U)}else break;return O}finish_call(O){let U=[];if(!this.check(Q.RIGHT_PAREN))do{if(U.length>=255)return q.report(new Z(this.peek(),"Can't have more than 255 arguments."));U.push(this.expression())}while(this.match(Q.COMMA));let $=this.consume(Q.RIGHT_PAREN,"Expect ')' after arguments.");return new UO(O,$,U)}unary(){if(this.match(Q.BANG,Q.MINUS)){let O=this.previous(),U=this.unary();return new t(O,U)}return this.call()}primary(){if(this.match(Q.FALSE))return new N(!1);if(this.match(Q.TRUE))return new N(!0);if(this.match(Q.NIL))return new N(null);if(this.match(Q.THIS))return new r(this.previous());if(this.match(Q.SUPER)){let O=this.previous();this.consume(Q.DOT,"Expect '.' after 'super'.");let U=this.consume(Q.IDENTIFIER,"Expect superclass method name.");return new p(O,U)}if(this.match(Q.NUMBER,Q.STRING))return new N(this.previous().literal);if(this.match(Q.LEFT_PAREN)){let O=this.expression();return this.consume(Q.RIGHT_PAREN,"Expect ')' after expression."),new e(O)}if(this.match(Q.IDENTIFIER))return new E(this.previous());return q.report(new Z(this.peek(),"Expect expression."))}expression(){return this.assignment()}assignment(){let O=this.or();if(this.match(Q.EQUAL)){let U=this.previous(),$=this.assignment();if(O instanceof E){let W=O.name;return new OO(W,$)}else if(O instanceof v){let W=O;return new n(W.object,W.name,$)}q.report(new Z(U,"Invalid assignment target."))}return O}or(){let O=this.and();while(this.match(Q.OR)){let U=this.previous(),$=this.and();O=new u(O,U,$)}return O}and(){let O=this.equality();while(this.match(Q.AND)){let U=this.previous(),$=this.equality();O=new u(O,U,$)}return O}consume(O,U){if(this.check(O))return this.advance();return q.report(new Z(this.peek(),U))}match(...O){for(let U of O)if(this.check(U))return this.advance(),!0;return!1}check(O){if(this.is_at_end())return!1;return this.peek().type===O}advance(){if(!this.is_at_end())this.current++;return this.previous()}previous(){return this.tokens[this.current-1]}peek(){return this.tokens[this.current]}is_at_end(){return this.peek().type==="EOF"}synchronize(){this.advance();while(this.is_at_end()){if(this.previous().type===Q.SEMICOLON)return;switch(this.peek().type){case Q.CLASS:case Q.FUN:case Q.VAR:case Q.FOR:case Q.IF:case Q.WHILE:case Q.PRINT:case Q.RETURN:return}this.advance()}}}var V;(function(H){H["None"]="None";H["Function"]="Function";H["Initializer"]="Initializer";H["Method"]="Method"})(V||(V={}));var M;(function(W){W["None"]="None";W["Class"]="Class";W["SubClass"]="SubClass"})(M||(M={}));class AO extends Array{constructor(){super(...arguments)}is_empty(){return this.length<1}peek(){return this[this.length-1]}}class HO{O;scopes=new AO;currentFunction=V.None;currentClass=M.None;constructor(O){this.interpreter=O;this.interpreter=O}resolve(O){if(O instanceof Array)O.forEach((U)=>this.resolve(U));else O.accept(this)}resolve_local(O,U){for(let $=this.scopes.length-1;$>=0;$--)if(this.scopes[$].has(U.lexeme)){this.interpreter.resolve(O,this.scopes.length-1-$);return}}begin_scope(){this.scopes.push(new Map)}end_scope(){this.scopes.pop()}declare(O){if(this.scopes.is_empty())return;this.scopes.peek().set(O.lexeme,!1)}define(O){if(this.scopes.is_empty())return;this.scopes.peek().set(O.lexeme,!0)}resolve_function(O,U){const $=this.currentFunction;this.currentFunction=U,this.begin_scope(),O.params.forEach((W)=>{this.declare(W),this.define(W)}),this.resolve(O.body),this.end_scope(),this.currentFunction=$}visitClassStmt(O){const U=this.currentClass;if(this.currentClass=M.Class,this.declare(O.name),this.define(O.name),O.superclass!==null)if(O.name.lexeme===O.superclass.name.lexeme)q.report(new SyntaxError("A class can't inherit from itself."));else this.currentClass=M.SubClass,this.resolve(O.superclass),this.begin_scope(),this.scopes.peek().set("super",!0);this.begin_scope(),this.scopes.peek().set("this",!0);for(let $ of O.methods){let W=V.Method;if($.name.lexeme==="init")W=V.Initializer;this.resolve_function($,W)}if(this.end_scope(),O.superclass!==null)this.end_scope();this.currentClass=U}visitBlockStmt(O){this.begin_scope(),this.resolve(O.statements),this.end_scope()}visitVarStmt(O){if(this.declare(O.name),O.initializer!==null)this.resolve(O.initializer);this.define(O.name)}visitVariableExpr(O){if(!this.scopes.is_empty()&&this.scopes.peek().get(O.name.lexeme)===!1)q.report(new P(O.name,"Cannot read local variable in its own initializer."));this.resolve_local(O,O.name)}visitAssignExpr(O){this.resolve(O.value),this.resolve_local(O,O.name)}visitSuperExpr(O){if(this.currentClass===M.None)q.report(new P(O.keyword,"Cannot use 'super' outside of a class."));else if(this.currentClass!==M.SubClass)q.report(new P(O.keyword,"Cannot use 'super' in a class with no superclass."));this.resolve_local(O,O.keyword)}visitFunctionStmt(O){this.declare(O.name),this.define(O.name),this.resolve_function(O,V.Function)}visitExpressionStmt(O){this.resolve(O.expression)}visitIfStmt(O){if(this.resolve(O.condition),this.resolve(O.thenBranch),O.elseBranch!==null)this.resolve(O.elseBranch)}visitPrintStmt(O){this.resolve(O.expression)}visitReturnStmt(O){if(O.value!==null){if(this.currentFunction===V.Initializer)q.report(new P(O.keyword,"Cannot return a value from an initializer."));if(this.currentFunction===V.None)q.report(new P(O.keyword,"Cannot return from top-level code."));this.resolve(O.value)}}visitWhileStmt(O){this.resolve(O.condition),this.resolve(O.body)}visitForStmt(O){if(O.initializer!==null)this.resolve(O.initializer);if(O.condition!==null)this.resolve(O.condition);if(O.increment!==null)this.resolve(O.increment)}visitBinaryExpr(O){this.resolve(O.left),this.resolve(O.right)}visitCallExpr(O){this.resolve(O.callee),O.args.forEach((U)=>this.resolve(U))}visitGroupingExpr(O){this.resolve(O.expression)}visitLiteralExpr(O){}visitUnaryExpr(O){this.resolve(O.right)}visitLogicalExpr(O){this.resolve(O.left),this.resolve(O.right)}visitSetExpr(O){this.resolve(O.value),this.resolve(O.object)}visitGetExpr(O){this.resolve(O.object)}visitThisExpr(O){if(this.currentClass===M.None){q.report(new P(O.keyword,"Cannot use 'this' outside of a class."));return}this.resolve_local(O,O.keyword)}}class g{type;lexeme;literal;line;constructor(O,U,$,W){this.type=O,this.lexeme=U,this.literal=$,this.line=W}to_string(){return`${this.type} ${this.lexeme} ${this.literal}`}}class qO{logger=new m;tokens;source;current=0;start=0;line=1;constructor(){this.source="",this.tokens=[],this.current=0,this.start=0,this.line=1}add_source(O){this.source+=O,this.current=0,this.start=0,this.line=1}set_source(O){this.source=O}reset_scanner(){this.tokens=[],this.source="",this.current=0,this.start=0,this.line=1}scan_tokens(){while(!this.is_end())this.start=this.current,this.scan();this.tokens.push(new g(Q.EOF,"",null,this.line))}is_end(){return this.current>=this.source.length}advance(){return this.source.charAt(this.current++)}match(O){if(this.is_end())return!1;if(this.source.charAt(this.current)!==O)return!1;return this.current++,!0}add_token(O,U){let $=this.source.substring(this.start,this.current),W=new g(O,$,U,this.line);this.tokens.push(W)}peek(){return this.source.charAt(this.current)}current_char(){return this.source.charAt(this.current-1)}is_digit(O){return O>="0"&&O<="9"}is_alpha(O){return O>="a"&&O<="z"||O>="A"&&O<="Z"||O==="_"}is_alpha_numeric(O){return this.is_alpha(O)||this.is_digit(O)}identifier(){while(this.is_alpha_numeric(this.peek()))this.advance();let O=this.source.substring(this.start,this.current);const U=SO[O];if(U!==void 0)this.add_token(U,null);else this.add_token(Q.IDENTIFIER,null)}string(){while(this.peek()!=='"'&&!this.is_end()){if(this.peek()==="\n")this.line++;this.advance()}if(this.is_end())q.report(new Z(null,"Unterminated string.at line "+this.line+" column "+this.current+""));this.advance();let O=this.source.substring(this.start+1,this.current-1);this.add_token(Q.STRING,O)}number(){while(this.is_digit(this.peek()))this.advance();if(this.peek()==="."&&this.is_digit(this.peek()))this.advance();let O=this.source.substring(this.start,this.current),U=parseFloat(O);this.add_token(Q.NUMBER,U)}scan(){let O=this.advance();switch(O){case"{":this.add_token(Q.LEFT_BRACE,null);break;case"}":this.add_token(Q.RIGHT_BRACE,null);break;case"(":this.add_token(Q.LEFT_PAREN,null);break;case")":this.add_token(Q.RIGHT_PAREN,null);break;case"\u2795":case"+":this.add_token(Q.PLUS,null);break;case"\u2796":case"-":this.add_token(Q.MINUS,null);break;case"\u2716":case"\u274C":case"*":this.add_token(Q.STAR,null);break;case"\u2797":case"/":if(this.match("/"))while(this.peek()!="\n"&&!this.is_end())this.advance();else this.add_token(Q.SLASH,null);break;case"\u2714":this.add_token(Q.EQUAL_EQUAL,null);break;case"=":this.add_token(this.match("=")?Q.EQUAL_EQUAL:Q.EQUAL,null);break;case"o":if(this.match("r"))this.add_token(Q.OR,null);break;case",":this.add_token(Q.COMMA,null);break;case".":this.add_token(Q.DOT,null);break;case"\u2757":this.add_token(Q.BANG_EQUAL,null);break;case"!":this.add_token(this.match("=")?Q.BANG_EQUAL:Q.BANG,null);break;case"\u2B05":this.add_token(Q.LESS_EQUAL,null);break;case"<":this.add_token(this.match("=")?Q.LESS_EQUAL:Q.LESS,null);break;case"\u27A1":this.add_token(Q.GREATER_EQUAL,null);break;case">":this.add_token(this.match("=")?Q.GREATER_EQUAL:Q.GREATER,null);break;case"\n":this.line++;break;case"\t":break;case'"':this.string();break;case" ":case"\r":break;case";":this.add_token(Q.SEMICOLON,null);break;default:if(this.is_digit(O))this.number();else if(this.is_alpha(O))this.identifier();else q.report(new Z(null,"Unexpected character."));break}}get_tokens(){return this.tokens}print_tokens(){this.logger.info(this.tokens)}}class DO{interpreter;resolver;astPrinter;parser;scanner;MODE;constructor(){this.scanner=new qO,this.interpreter=new WO,this.resolver=new HO(this.interpreter),this.parser=new GO([]),this.astPrinter=new $O,Bun.argv[2]===void 0?this.MODE="REPL":this.MODE="FILE"}run(){if(this.MODE==="FILE")IO((O)=>{this.scanner.set_source(O),this.scanner.scan_tokens();const U=this.scanner.get_tokens();this.parser.set_tokens(U);const $=this.parser.parse();this.resolver.resolve($),this.print_ast($),console.log(L.blue("                                                 ")),console.log(L.blue("================      Compiled Output       ================")),console.log(L.blue("                                                 ")),this.interpreter.interpret($)});else console.log("REPL is still in progress\n"),console.log("Usage: beer [script]")}print_ast(O){console.log(L.cyan("================      AST       ================")),console.log(L.cyan("                                                 ")),this.astPrinter.print_ast(O)}}var dO=new DO;dO.run();
